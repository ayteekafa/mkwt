<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MKWT – App</title>

  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

  
  

  <link rel="stylesheet" href="mkwt_theme_v3.css">
</head>

<body>

  <nav class="nav">
  <div class="navInner">
    <div class="brand">MKWT</div>

    <a class="navLink" href="tracker.html">Tracker</a>
    <a class="navLink" href="stats.html">VR improvement</a>
    <a class="navLink" href="settings.html">Settings</a>

    <div class="navSpacer"></div>

    <div class="navRight">
      <button class="navAction" id="btnExport" type="button">Export</button>
      <label class="navAction">
        Import
        <input id="fileImport" type="file" accept="application/json" />
      </label>
      <button class="navAction danger" id="btnLogout" type="button">Logout</button>
    </div>
  </div>
</nav>


  <div class="wrap">

    <div class="card">
      <div class="row" style="align-items:center">
        <div>
          <h2 style="margin:0 0 6px 0;">MKWT</h2>
          <div class="muted" id="userInfo">Loading session…</div>
          <div class="muted">Current VR: <span class="pill" id="currentVrPill">–</span></div>
        </div>
      </div>
      <div class="muted" id="status"></div>
      <div class="muted" id="debug"></div>
    </div>

    <!-- SETUP (nur beim ersten Login, wenn kein Profil existiert) -->
    <div class="card hidden" id="setupCard">
      <h3 style="margin-top:0;">Create profile (one time)</h3>
      <div class="row">
        <div class="field">
          <label class="muted">Nickname</label>
          <input id="setupNickname" placeholder="z.B. Nickname" />
        </div>
        <div class="field">
          <label class="muted">Aktuelle VR</label>
          <input id="setupVr" type="number" inputmode="numeric" placeholder="z.B. 8500" />
          <div class="muted">Wenn leer: Default ist 8500.</div>
        </div>
      </div>
      <div style="display:flex; gap:10px; margin-top:12px;">
        <button class="btn" id="btnCreateProfile">Create profile</button>
      </div>
    </div>

    <!-- SETTINGS (immer verfügbar, wenn Profil existiert) -->
    
<!-- settingsCard removed (moved to settings.html) -->


    <!-- MATCH INPUT -->
    <div class="card hidden" id="matchCard">
      <h3 style="margin-top:0;">Add new match</h3>

      <!-- Mode toggle: Intermission vs 3-Lap -->
      <div class="modeToggle" role="tablist" aria-label="Match mode">
        <button type="button" class="modeBtn isActive" data-mode="intermission" aria-selected="true">Intermission</button>
        <button type="button" class="modeBtn" data-mode="3lap" aria-selected="false">3-Lap track</button>
      </div>

      <div class="row">
  <div class="field" id="fieldIntermissionStart">
    <label class="muted" id="labelIntermissionStart">Intermission start</label>
    <select id="intermission">
      <option value="">Intermission start</option>
      <option>Acorn Heights</option>
      <option>Airship Fortress</option>
      <option>Boo Cinema</option>
      <option>Bowser's Castle</option>
      <option>Cheep Cheep Falls</option>
      <option>Choco Mountain</option>
      <option>Crown City</option>
      <option>Dandelion Depths</option>
      <option>Desert Hills</option>
      <option>Dino Dino Jungle</option>
      <option>DK Pass</option>
      <option>DK Spaceport</option>
      <option>Dry Bones Burnout</option>
      <option>Faraway Oasis</option>
      <option>Great Block Ruins</option>
      <option>Koopa Troopa Beach</option>
      <option>Mario Bros Circuit</option>
      <option>Mario Circuit</option>
      <option>Moo Moo Meadows</option>
      <option>Peach Beach</option>
      <option>Peach Stadium</option>
      <option>Rainbow Road</option>
      <option>Salty Salty Speedway</option>
      <option>Shy Guy Bazaar</option>
      <option>Sky-High Sundae</option>
      <option>Starview Peak</option>
      <option>Toad's Factory</option>
      <option>Wario Shipyard</option>
      <option>Wario Stadium</option>
      <option>Whistlestop Summit</option>
    </select>
  </div>

  <div class="field" id="fieldTrack">
    <label class="muted" id="labelTrack">Intermission end</label>
    <select id="track">
      <option value="" id="trackPlaceholder">Intermission end</option>
      <option>Acorn Heights</option>
      <option>Airship Fortress</option>
      <option>Boo Cinema</option>
      <option>Bowser's Castle</option>
      <option>Cheep Cheep Falls</option>
      <option>Choco Mountain</option>
      <option>Crown City</option>
      <option>Dandelion Depths</option>
      <option>Desert Hills</option>
      <option>Dino Dino Jungle</option>
      <option>DK Pass</option>
      <option>DK Spaceport</option>
      <option>Dry Bones Burnout</option>
      <option>Faraway Oasis</option>
      <option>Great Block Ruins</option>
      <option>Koopa Troopa Beach</option>
      <option>Mario Bros Circuit</option>
      <option>Mario Circuit</option>
      <option>Moo Moo Meadows</option>
      <option>Peach Beach</option>
      <option>Peach Stadium</option>
      <option>Rainbow Road</option>
      <option>Salty Salty Speedway</option>
      <option>Shy Guy Bazaar</option>
      <option>Sky-High Sundae</option>
      <option>Starview Peak</option>
      <option>Toad's Factory</option>
      <option>Wario Shipyard</option>
      <option>Wario Stadium</option>
      <option>Whistlestop Summit</option>
    </select>
  </div>
</div>

      <div class="row">
        <div class="field">
          <label class="muted">VR Δ</label>
          <div class="vr-delta-wrap">
            <button type="button" id="vrSignToggle" class="vr-sign" aria-label="Toggle negative">−</button>
            <input id="vrChange" placeholder="0" type="text" inputmode="numeric" pattern="[0-9]*">
          </div>
        </div>
        <div class="field">
          <label class="muted">new total VR</label>
          <input id="vrAfterInput" placeholder="z.B. 7980" type="text" inputmode="numeric" pattern="[0-9]*">
          <div class="muted"></div>
        </div>

        <div class="field">
          <label class="muted">Opponents</label>
          <select id="opponents">
            <option value="">—</option>
            <optgroup label="Häufig (15–23)">
              <option>15</option><option>16</option><option>17</option><option>18</option><option>19</option>
              <option>20</option><option>21</option><option>22</option><option>23</option>
            </optgroup>
            <optgroup label="Alle (1–23)">
              <option>1</option><option>2</option><option>3</option><option>4</option><option>5</option><option>6</option>
              <option>7</option><option>8</option><option>9</option><option>10</option><option>11</option><option>12</option>
              <option>13</option><option>14</option><option>15</option><option>16</option><option>17</option><option>18</option>
              <option>19</option><option>20</option><option>21</option><option>22</option><option>23</option>
            </optgroup>
          </select>
        </div>

        <div class="field">
          <label class="muted">Placement</label>
          <select id="placement">
            <option value="">—</option>
            <option>1</option><option>2</option><option>3</option><option>4</option><option>5</option><option>6</option>
            <option>7</option><option>8</option><option>9</option><option>10</option><option>11</option><option>12</option>
            <option>13</option><option>14</option><option>15</option><option>16</option><option>17</option><option>18</option>
            <option>19</option><option>20</option><option>21</option><option>22</option><option>23</option><option>24</option>
          </select>
        </div>
      </div>

      <div style="display:flex; gap:10px; margin-top:12px;">
        <button class="btn" id="btnSaveMatch">Save</button>
        <button class="btn2" id="btnClear">Clear</button>
      </div>
    </div>

    <!-- MATCH LIST -->
    <div class="card hidden" id="listCard">
  <h3 style="margin-top:0;">Recent matches</h3>
  <div class="muted" style="margin-bottom:10px;">
    
  </div>

  <div style="overflow:auto; max-height: 520px;">
  <table>
    <thead>
        <tr>
          <th>Match #</th>
          <th>Created</th>
          <th>Intermission</th>
          <th>Track</th>
          <th>VR Δ</th>
          <th>VR after</th>
          <th>Opp</th>
          <th>Place</th>
                    <th style="text-align:right;">Actions</th>
        </tr>
      </thead>
      <tbody id="rows">
        <tr><td colspan="10" class="muted">Loading…</td></tr>
      </tbody>
    </table>
    <div class="row" style="align-items:center; margin-top:10px;">
  <div class="muted" id="pageInfo">Page 1</div>
  <div style="display:flex; gap:10px; justify-content:flex-end;">
    <button class="btn2" id="btnPrev">← Prev</button>
    <button class="btn2" id="btnNext">Next →</button>
  </div>
</div>
  </div>
</div>
    <!-- EDIT DIALOG -->
    <dialog id="editDlg">
    <div style="padding:16px; border-bottom:1px solid #2d3442; display:flex; justify-content:space-between; align-items:center;">
        <div>
        <div style="font-weight:800;">Edit match</div>
        <div class="muted" id="editMeta">—</div>
        </div>
        <button class="btn2" id="btnCloseDlg">✕</button>
    </div>

    <div style="padding:16px;">
        <div class="modeToggleRow">
          <button type="button" class="modeBtnSmall isActive" id="editModeIntermission" data-mode="intermission">Intermission</button>
          <button type="button" class="modeBtnSmall" id="editMode3lap" data-mode="3lap">3-Lap track</button>
        </div>
        <div class="row">
        <div class="field" id="editIntermissionField">
            <label class="muted" id="editIntermissionLabel">Intermission start</label>
            <select id="editIntermission"></select>
        </div>
        <div class="field">
            <label class="muted" id="editTrackLabel">Intermission end</label>
            <select id="editTrack"></select>
        </div>
        </div>

        <div class="row">
        <div class="field">
            <label class="muted">VR Δ</label>
            <div class="vr-delta-wrap">
              <button type="button" id="editVrSignToggle" class="vr-sign" aria-label="Toggle negative">−</button>
              <input id="editVrChange" type="text" inputmode="numeric" pattern="[0-9]*" placeholder="VR change" />
            </div>
        </div>
        <div class="field">
            <label class="muted">new total VR</label>
            <input id="editVrAfter" type="number" inputmode="numeric" placeholder="e.g. 9000" />
        </div>
        <div class="field">
            <label class="muted">total opponents</label>
            <input id="editOpponents"
       type="number"
       min="1"
       max="23"
       inputmode="numeric"
       list="editOppList"
       placeholder="1–23" />

<datalist id="editOppList">
  <option value="8"></option>
  <option value="12"></option>
  <option value="16"></option>
  <option value="18"></option>
  <option value="20"></option>
  <option value="21"></option>
  <option value="22"></option>
  <option value="23"></option>
</datalist>
        </div>
        <div class="field">
            <label class="muted">Placement (1–24)</label>
           <input id="editPlacement"
       type="number"
       min="1"
       max="24"
       inputmode="numeric"
       list="editPlaceList"
       placeholder="1–24" />

<datalist id="editPlaceList">
  <option value="1"></option>
  <option value="2"></option>
  <option value="3"></option>
  <option value="4"></option>
  <option value="5"></option>
  <option value="6"></option>
  <option value="7"></option>
  <option value="8"></option>
  <option value="9"></option>
  <option value="10"></option>
  <option value="11"></option>
  <option value="12"></option>
  <option value="13"></option>
  <option value="14"></option>
  <option value="15"></option>
  <option value="16"></option>
  <option value="17"></option>
  <option value="18"></option>
  <option value="19"></option>
  <option value="20"></option>
  <option value="21"></option>
  <option value="22"></option>
  <option value="23"></option>
  <option value="24"></option>
</datalist>
        </div>
        </div>

        <div class="muted" style="margin-top:10px;">
        Note: Enter VR Δ OR new total VR. Your current VR will be adjusted automatically.
        </div>
    </div>

    <div style="padding:16px; border-top:1px solid #2d3442; display:flex; gap:10px; justify-content:flex-end;">
        <button class="btn2" id="btnCancelDlg">Cancel</button>
        <button class="btn" id="btnSaveDlg">Save</button>
    </div>
    </dialog>
<script>

// ===== Suggestion (next Intermission start) =====
function getLastSuggestedTrack() {
  try { return localStorage.getItem('mkwt_last_next_start') || ''; } catch(e) { return ''; }
}
function setLastSuggestedTrack(name) {
  try { if (!name) return; localStorage.setItem('mkwt_last_next_start', String(name)); } catch(e) {}
}
function getSuggestedNextStart() {
  return getLastSuggestedTrack();
}

// If a "suggested next start" exists AND it is currently allowed,
// we move that track to the very top of the Intermission-start dropdown (right under the placeholder).
// No special values, no prefixes, no extra "Suggestion" option.
function applyStartSuggestionOrdering(selectEl){
  try {
    const isStartSelect = (selectEl?.id === 'intermission' || selectEl?.id === 'editIntermission');
    if (!isStartSelect) return;
    const suggested = (getSuggestedNextStart?.() || '');
    if (!suggested) return;
    const opt = selectEl.querySelector(`option[value="${CSS.escape(suggested)}"]`);
    if (!opt) return; // suggested not in current allowed list
    // Move right after placeholder (index 1)
    const placeholderOpt = selectEl.querySelector('option[value=""]');
    if (!placeholderOpt) return;
    if (opt === placeholderOpt.nextSibling) return;
    selectEl.insertBefore(opt, placeholderOpt.nextSibling);
  } catch(e) {}
}

// Refresh the *displayed* Suggestion option in the Intermission start dropdown
// without resetting the user's current selections or the existing filter logic.
function refreshSuggestionOptionInStartSelect(selectEl){
  // Legacy name kept to avoid touching existing call sites.
  // Ensures EXACTLY ONE highlighted suggested option (★) at the top (if allowed) without changing values.
  try {
    const isStartSelect = (selectEl?.id === 'intermission' || selectEl?.id === 'editIntermission');
    if (!isStartSelect) return;

    const suggested = (getSuggestedNextStart?.() || '');
    const placeholderOpt = selectEl.querySelector('option[value=""]');

    // Remove any previous visual markers so old suggestions never linger.
    for (const opt of Array.from(selectEl.querySelectorAll('option'))){
      if (opt.value === '') continue;
      if (opt.textContent && opt.textContent.startsWith('★ ')) {
        opt.textContent = opt.textContent.slice(2);
      }
      if (opt.dataset) delete opt.dataset.suggested;
    }

    if (!suggested) return;
    const opt = selectEl.querySelector(`option[value="${CSS.escape(suggested)}"]`);
    if (!opt || !placeholderOpt) return; // not allowed / not present

    opt.textContent = `★ ${suggested}`;
    opt.dataset.suggested = '1';
    if (opt !== placeholderOpt.nextSibling) {
      selectEl.insertBefore(opt, placeholderOpt.nextSibling);
    }
  } catch(e) {}
}

// Read the currently top-most match's *target track* from the rendered table.
// - If the match is an intermission match, this is the End track.
// - If it's a normal 3-lap match, this is the Track value.
function getTopMatchTargetTrackFromTable(){
  try {
    const firstTr = document.querySelector('#rows tr');
    if (!firstTr) return '';

    const cells = firstTr.children;
    if (!cells || cells.length < 4) return '';

    const interCell = cells[2];
    const trackCell = cells[3];

    // Intermission row: End is the 2nd .value within .intermission-stack
    const stack = interCell?.querySelector?.('.intermission-stack');
    if (stack) {
      const vals = stack.querySelectorAll('.value');
      const end = vals?.[1]?.textContent?.trim?.() || '';
      return end;
    }

    // Normal row: Track is the track cell's text
    return (trackCell?.textContent || '').trim();
  } catch(e) {
    return '';
  }
}
  // ========= Fehler sichtbar machen =========
  window.addEventListener("error", (e) => {
    const msg = "JS Error: " + (e.message || e.type);
    document.getElementById("status").textContent = msg;
    document.getElementById("debug").textContent = (e.error?.stack || "");
  });

  // ========= Helpers =========
  const $ = (id) => document.getElementById(id);
  const $status = $("status");
  const $debug  = $("debug");
  const $rows   = $("rows");

  function setStatus(msg, ok=false){
    $status.className = "muted " + (ok ? "ok" : "bad");
    $status.textContent = msg || "";
  }
  function setDebug(msg){ $debug.textContent = msg || ""; }
  function show(el, on){ el.classList.toggle("hidden", !on); }

  // ========= VR Δ <-> VR nach Match Sync =========
  // ========= Edit VR Δ <-> new total VR Sync =========
  let _syncingEditVr = false;

  function getEditBaseVr(){
    // base VR before this match = vr_after - vr_change (from stored snapshot)
    const after = Number(EDIT_ROW?.vr_after);
    const delta = Number(EDIT_ROW?.vr_change ?? 0);
    if (Number.isFinite(after)) return after - delta;

    // fallback if old rows had no vr_after: assume current profile VR minus old delta
    const cur = Number(PROFILE?.current_vr ?? 8500);
    return cur - delta;
  }

  function editSyncFromDelta(){
    if (_syncingEditVr) return;
    const elDelta = $("editVrChange");
    const elAfter = $("editVrAfter");
    if (!elDelta || !elAfter) return;

    const d = Number(elDelta.value);
    if (!Number.isFinite(d)) { elAfter.value = ""; return; }

    _syncingEditVr = true;
    elAfter.value = String(getEditBaseVr() + d);
    _syncingEditVr = false;
  }

  function editSyncFromAfter(){
    if (_syncingEditVr) return;
    const elDelta = $("editVrChange");
    const elAfter = $("editVrAfter");
    if (!elDelta || !elAfter) return;

    const a = Number(elAfter.value);
    if (!Number.isFinite(a)) { elDelta.value = ""; return; }

    _syncingEditVr = true;
    elDelta.value = String(a - getEditBaseVr());
    _syncingEditVr = false;
  }

  let _syncingVr = false;
  function getBaseVr(){
    return Number(PROFILE?.current_vr ?? 8500);
  }
  function syncFromDelta(){
    if (_syncingVr) return;
    const elDelta = $("vrChange");
    const elAfter = $("vrAfterInput");
    if (!elDelta || !elAfter) return;
    const d = Number(elDelta.value);
    if (!Number.isFinite(d)) { elAfter.value = ""; return; }
    _syncingVr = true;
    elAfter.value = String(getBaseVr() + d);
    _syncingVr = false;
  }
  function syncFromAfter(){
    if (_syncingVr) return;
    const elDelta = $("vrChange");
    const elAfter = $("vrAfterInput");
    if (!elDelta || !elAfter) return;
    const a = Number(elAfter.value);
    if (!Number.isFinite(a)) { elDelta.value = ""; return; }
    _syncingVr = true;
    elDelta.value = String(a - getBaseVr());
    _syncingVr = false;
  }


  function escapeHtml(s){
  return String(s ?? "").replace(/[&<>"']/g, (c) => ({
    "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
  }[c]));
}
function downloadTextFile(filename, text) {
  const blob = new Blob([text], { type: "application/json;charset=utf-8" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

async function exportBackupJSON() {
  try {
    setStatus("Creating backup…", true);

    // 1) Profil laden (zur Sicherheit frisch)
    await loadProfile();

    // 2) Alle Matches paginiert holen (Supabase max. 1000/Request ist üblich)
    const allMatches = [];
    const chunk = 1000;
    let from = 0;

    while (true) {
      const to = from + chunk - 1;

      const { data, error } = await supabaseClient
        .from("matches")
        .select("id, created_at, intermission, track, vr_change, vr_after, opponents, placement")
        .eq("user_id", SESSION.user.id)
        .order("created_at", { ascending: true }) // Backup chronologisch
        .range(from, to);

      if (error) throw error;
      if (!data || data.length === 0) break;

      allMatches.push(...data);
      if (data.length < chunk) break;
      from += chunk;
    }

    const backup = {
      app: "MKWT",
      version: 1,
      exported_at: new Date().toISOString(),
      user: {
        id: SESSION.user.id,
        email: SESSION.user.email || null
      },
      profile: {
        nickname: PROFILE?.nickname ?? null,
        current_vr: PROFILE?.current_vr ?? null
      },
      matches: allMatches
    };

    const filename = `mkwt_backup_${(PROFILE?.nickname || "user").replace(/\s+/g, "_")}_${new Date().toISOString().slice(0,10)}.json`;
    downloadTextFile(filename, JSON.stringify(backup, null, 2));

    setStatus(`✅ Backup created (${allMatches.length} Matches).`, true);
  } catch (e) {
    setStatus("Backup failed: " + (e?.message || e), false);
    setDebug(e?.stack || JSON.stringify(e, null, 2));
  }
}
async function importBackupJSON(file) {
  try {
    if (!file) return;

    const text = await file.text();
    const backup = JSON.parse(text);

    if (!backup || backup.app !== "MKWT" || !Array.isArray(backup.matches)) {
      setStatus("❌ Datei ist kein gültiges MKWT Backup.", false);
      return;
    }

    const ok = confirm(
      `Restore starten?\n\n` +
      `Matches in Datei: ${backup.matches.length}\n\n` +
      `Wichtig: Nach dem Restore entspricht deine Match-Historie exakt dem Backup.\n` +
      `Alle Matches, die NICHT im Backup sind, werden gelöscht.`
    );
    if (!ok) return;

    setStatus("Importing…", true);

    // --- Build backup fingerprint set ---
    const backupFp = new Set();
    for (const r of backup.matches) backupFp.add(fingerprintMatch(r));

    // --- Load all existing matches (for this user) incl. id for deletes ---
    const existingFp = new Set();
    const existingToDeleteIds = [];
    const chunk = 1000;
    let from = 0;

    while (true) {
      const to = from + chunk - 1;
      const { data, error } = await supabaseClient
        .from("matches")
        .select("id, created_at, intermission, track, vr_change, opponents, placement")
        .eq("user_id", SESSION.user.id)
        .range(from, to);

      if (error) throw error;
      if (!data || data.length === 0) break;

      for (const row of data) {
        const fp = fingerprintMatch(row);
        existingFp.add(fp);
        if (!backupFp.has(fp)) existingToDeleteIds.push(row.id);
      }

      if (data.length < chunk) break;
      from += chunk;
    }

    // --- Delete matches that are not in backup ---
    let deleted = 0;
    const delBatchSize = 500;
    for (let i = 0; i < existingToDeleteIds.length; i += delBatchSize) {
      const batchIds = existingToDeleteIds.slice(i, i + delBatchSize);
      const { error } = await supabaseClient
        .from("matches")
        .delete()
        .in("id", batchIds);
      if (error) throw error;
      deleted += batchIds.length;
    }

    // --- Insert matches that are in backup but not present ---
    const toInsert = [];
    for (const r of backup.matches) {
      const fp = fingerprintMatch(r);
      if (!existingFp.has(fp)) {
        toInsert.push({
          user_id: SESSION.user.id,
          created_at: r.created_at,
          intermission: r.intermission ?? null,
          track: r.track ?? null,
          vr_change: r.vr_change ?? 0,
          vr_after: r.vr_after ?? null,
          opponents: r.opponents ?? null,
          placement: r.placement ?? null,
        });
      }
    }

    let inserted = 0;
    const insBatchSize = 500;
    for (let i = 0; i < toInsert.length; i += insBatchSize) {
      const batch = toInsert.slice(i, i + insBatchSize);
      const { error } = await supabaseClient.from("matches").insert(batch);
      if (error) throw error;
      inserted += batch.length;
    }

    setStatus(
      `✅ Restore complete. Backup matches: ${backup.matches.length} | Deleted: ${deleted} | Inserted: ${inserted}`,
      true
    );

    // After restore, auto-set profile Current VR to the latest match's vr_after (if available)
    await syncProfileVrFromLatestMatch();

    await refreshAll();
  } catch (e) {
    setStatus("Import failed: " + (e?.message || e), false);
    setDebug(e?.stack || JSON.stringify(e, null, 2));
  }
}


function fingerprintMatch(r) {
  // Stabiler Vergleich (stringify null/undefined)
  const created = r.created_at ? String(r.created_at) : "";
  return [
    created,
    String(r.intermission ?? ""),
    String(r.track ?? ""),
    String(r.vr_change ?? ""),
    String(r.opponents ?? ""),
    String(r.placement ?? "")
  ].join("|");
}

// ========= Helper: set Profile current_vr from latest match (vr_after) =========
async function syncProfileVrFromLatestMatch(){
  try{
    const { data, error } = await supabaseClient
      .from("matches")
      .select("vr_after, created_at")
      .eq("user_id", SESSION.user.id)
      .order("created_at", { ascending: false })
      .limit(1);

    if (error) throw error;

    const latest = (data && data[0]) ? data[0] : null;
    const latestVr = Number(latest?.vr_after);

    if (!Number.isFinite(latestVr)) return false;

    const { error: upErr } = await supabaseClient
      .from("profiles")
      .update({ current_vr: latestVr, updated_at: new Date().toISOString() })
      .eq("id", SESSION.user.id);

    if (upErr) throw upErr;

    // keep local PROFILE in sync for immediate UI calculations
    if (PROFILE) PROFILE.current_vr = latestVr;
    return true;
  } catch(e){
    // don't hard-fail import/export; just surface debug
    setDebug("syncProfileVrFromLatestMatch error: " + (e?.message || e));
    return false;
  }
}

// ========= Track-Liste =========
// Track names normalized to match the Intermission route JSON exactly.
const TRACKS = [
  "Acorn Heights","Airship Fortress","Boo Cinema","Bowser's Castle","Cheep Cheep Falls",
  "Choco Mountain","Crown City","Dandelion Depths","Desert Hills","Dino Dino Jungle",
  "DK Pass","DK Spaceport","Dry Bones Burnout","Faraway Oasis","Great ? Block Ruins",
  "Koopa Troopa Beach","Mario Circuit","Mario Bros. Circuit","Moo Moo Meadows",
  "Peach Beach","Peach Stadium","Rainbow Road","Salty Salty Speedway","Shy Guy Bazaar",
  "Sky-High Sundae","Starview Peak","Toad's Factory","Wario Shipyard","Wario Stadium",
  "Whistlestop Summit"
];

// All Intermission combinations (Start -> End). Used to filter the dropdowns.
// NOTE: keep spelling identical to TRACKS.
const INTERMISSION_ROUTES = [
  {"from":"Acorn Heights","to":"Boo Cinema"},{"from":"Acorn Heights","to":"Dandelion Depths"},{"from":"Acorn Heights","to":"Dry Bones Burnout"},{"from":"Acorn Heights","to":"Mario Circuit"},{"from":"Acorn Heights","to":"Toad's Factory"},
  {"from":"Airship Fortress","to":"Bowser's Castle"},{"from":"Airship Fortress","to":"Dry Bones Burnout"},{"from":"Airship Fortress","to":"Shy Guy Bazaar"},{"from":"Airship Fortress","to":"Toad's Factory"},{"from":"Airship Fortress","to":"Wario Stadium"},
  {"from":"Boo Cinema","to":"Acorn Heights"},{"from":"Boo Cinema","to":"Dandelion Depths"},{"from":"Boo Cinema","to":"Dry Bones Burnout"},{"from":"Boo Cinema","to":"Mario Circuit"},{"from":"Boo Cinema","to":"Starview Peak"},
  {"from":"Bowser's Castle","to":"Airship Fortress"},{"from":"Bowser's Castle","to":"Choco Mountain"},{"from":"Bowser's Castle","to":"Dry Bones Burnout"},{"from":"Bowser's Castle","to":"Mario Circuit"},{"from":"Bowser's Castle","to":"Toad's Factory"},{"from":"Bowser's Castle","to":"Wario Stadium"},
  {"from":"Cheep Cheep Falls","to":"Choco Mountain"},{"from":"Cheep Cheep Falls","to":"Dandelion Depths"},{"from":"Cheep Cheep Falls","to":"DK Pass"},{"from":"Cheep Cheep Falls","to":"Faraway Oasis"},{"from":"Cheep Cheep Falls","to":"Moo Moo Meadows"},{"from":"Cheep Cheep Falls","to":"Peach Stadium"},{"from":"Cheep Cheep Falls","to":"Salty Salty Speedway"},{"from":"Cheep Cheep Falls","to":"Sky-High Sundae"},{"from":"Cheep Cheep Falls","to":"Starview Peak"},{"from":"Cheep Cheep Falls","to":"Wario Shipyard"},
  {"from":"Choco Mountain","to":"Bowser's Castle"},{"from":"Choco Mountain","to":"Cheep Cheep Falls"},{"from":"Choco Mountain","to":"Crown City"},{"from":"Choco Mountain","to":"Mario Bros. Circuit"},{"from":"Choco Mountain","to":"Moo Moo Meadows"},{"from":"Choco Mountain","to":"Peach Stadium"},{"from":"Choco Mountain","to":"Shy Guy Bazaar"},{"from":"Choco Mountain","to":"Toad's Factory"},{"from":"Choco Mountain","to":"Wario Stadium"},{"from":"Choco Mountain","to":"Whistlestop Summit"},
  {"from":"Crown City","to":"Choco Mountain"},{"from":"Crown City","to":"Desert Hills"},{"from":"Crown City","to":"DK Spaceport"},{"from":"Crown City","to":"Faraway Oasis"},{"from":"Crown City","to":"Koopa Troopa Beach"},{"from":"Crown City","to":"Mario Bros. Circuit"},{"from":"Crown City","to":"Moo Moo Meadows"},{"from":"Crown City","to":"Peach Stadium"},{"from":"Crown City","to":"Wario Stadium"},{"from":"Crown City","to":"Whistlestop Summit"},
  {"from":"Dandelion Depths","to":"Acorn Heights"},{"from":"Dandelion Depths","to":"Boo Cinema"},{"from":"Dandelion Depths","to":"Cheep Cheep Falls"},{"from":"Dandelion Depths","to":"DK Pass"},{"from":"Dandelion Depths","to":"Mario Circuit"},{"from":"Dandelion Depths","to":"Moo Moo Meadows"},{"from":"Dandelion Depths","to":"Sky-High Sundae"},{"from":"Dandelion Depths","to":"Starview Peak"},{"from":"Dandelion Depths","to":"Toad's Factory"},
  {"from":"Desert Hills","to":"Crown City"},{"from":"Desert Hills","to":"DK Spaceport"},{"from":"Desert Hills","to":"Mario Bros. Circuit"},{"from":"Desert Hills","to":"Shy Guy Bazaar"},{"from":"Desert Hills","to":"Whistlestop Summit"},
  {"from":"Dino Dino Jungle","to":"Faraway Oasis"},{"from":"Dino Dino Jungle","to":"Great ? Block Ruins"},{"from":"Dino Dino Jungle","to":"Koopa Troopa Beach"},{"from":"Dino Dino Jungle","to":"Peach Beach"},{"from":"Dino Dino Jungle","to":"Salty Salty Speedway"},
  {"from":"DK Pass","to":"Dandelion Depths"},{"from":"DK Pass","to":"Moo Moo Meadows"},{"from":"DK Pass","to":"Salty Salty Speedway"},{"from":"DK Pass","to":"Sky-High Sundae"},{"from":"DK Pass","to":"Starview Peak"},{"from":"DK Pass","to":"Wario Shipyard"},{"from":"DK Pass","to":"Cheep Cheep Falls"},
  {"from":"DK Spaceport","to":"Crown City"},{"from":"DK Spaceport","to":"Koopa Troopa Beach"},{"from":"DK Spaceport","to":"Whistlestop Summit"},{"from":"DK Spaceport","to":"Peach Stadium"},{"from":"DK Spaceport","to":"Desert Hills"},{"from":"DK Spaceport","to":"Mario Bros. Circuit"},
  {"from":"Dry Bones Burnout","to":"Acorn Heights"},{"from":"Dry Bones Burnout","to":"Airship Fortress"},{"from":"Dry Bones Burnout","to":"Boo Cinema"},{"from":"Dry Bones Burnout","to":"Bowser's Castle"},{"from":"Dry Bones Burnout","to":"Mario Circuit"},{"from":"Dry Bones Burnout","to":"Moo Moo Meadows"},{"from":"Dry Bones Burnout","to":"Toad's Factory"},{"from":"Dry Bones Burnout","to":"Wario Stadium"},
  {"from":"Faraway Oasis","to":"Cheep Cheep Falls"},{"from":"Faraway Oasis","to":"Crown City"},{"from":"Faraway Oasis","to":"Dino Dino Jungle"},{"from":"Faraway Oasis","to":"Great ? Block Ruins"},{"from":"Faraway Oasis","to":"Koopa Troopa Beach"},{"from":"Faraway Oasis","to":"Peach Beach"},{"from":"Faraway Oasis","to":"Peach Stadium"},{"from":"Faraway Oasis","to":"Salty Salty Speedway"},
  {"from":"Great ? Block Ruins","to":"Dino Dino Jungle"},{"from":"Great ? Block Ruins","to":"Faraway Oasis"},{"from":"Great ? Block Ruins","to":"Peach Beach"},{"from":"Great ? Block Ruins","to":"Salty Salty Speedway"},{"from":"Great ? Block Ruins","to":"Koopa Troopa Beach"},
  {"from":"Koopa Troopa Beach","to":"Crown City"},{"from":"Koopa Troopa Beach","to":"Desert Hills"},{"from":"Koopa Troopa Beach","to":"DK Spaceport"},{"from":"Koopa Troopa Beach","to":"Dino Dino Jungle"},{"from":"Koopa Troopa Beach","to":"Faraway Oasis"},{"from":"Koopa Troopa Beach","to":"Peach Stadium"},{"from":"Koopa Troopa Beach","to":"Great ? Block Ruins"},{"from":"Koopa Troopa Beach","to":"Whistlestop Summit"},
  {"from":"Mario Bros. Circuit","to":"Choco Mountain"},{"from":"Mario Bros. Circuit","to":"Crown City"},{"from":"Mario Bros. Circuit","to":"Desert Hills"},{"from":"Mario Bros. Circuit","to":"DK Spaceport"},{"from":"Mario Bros. Circuit","to":"Shy Guy Bazaar"},{"from":"Mario Bros. Circuit","to":"Toad's Factory"},{"from":"Mario Bros. Circuit","to":"Wario Stadium"},{"from":"Mario Bros. Circuit","to":"Whistlestop Summit"},
  {"from":"Mario Circuit","to":"Acorn Heights"},{"from":"Mario Circuit","to":"Boo Cinema"},{"from":"Mario Circuit","to":"Bowser's Castle"},{"from":"Mario Circuit","to":"Dandelion Depths"},{"from":"Mario Circuit","to":"Dry Bones Burnout"},{"from":"Mario Circuit","to":"Moo Moo Meadows"},{"from":"Mario Circuit","to":"Starview Peak"},{"from":"Mario Circuit","to":"Toad's Factory"},
  {"from":"Moo Moo Meadows","to":"Cheep Cheep Falls"},{"from":"Moo Moo Meadows","to":"Choco Mountain"},{"from":"Moo Moo Meadows","to":"Crown City"},{"from":"Moo Moo Meadows","to":"Dandelion Depths"},{"from":"Moo Moo Meadows","to":"DK Pass"},{"from":"Moo Moo Meadows","to":"Dry Bones Burnout"},{"from":"Moo Moo Meadows","to":"Mario Circuit"},{"from":"Moo Moo Meadows","to":"Peach Stadium"},{"from":"Moo Moo Meadows","to":"Toad's Factory"},
  {"from":"Peach Beach","to":"Dino Dino Jungle"},{"from":"Peach Beach","to":"Faraway Oasis"},{"from":"Peach Beach","to":"Great ? Block Ruins"},{"from":"Peach Beach","to":"Salty Salty Speedway"},{"from":"Peach Beach","to":"Wario Shipyard"},
  {"from":"Peach Stadium","to":"Cheep Cheep Falls"},{"from":"Peach Stadium","to":"Choco Mountain"},{"from":"Peach Stadium","to":"Crown City"},{"from":"Peach Stadium","to":"DK Spaceport"},{"from":"Peach Stadium","to":"Faraway Oasis"},{"from":"Peach Stadium","to":"Koopa Troopa Beach"},{"from":"Peach Stadium","to":"Mario Circuit"},{"from":"Peach Stadium","to":"Moo Moo Meadows"},{"from":"Peach Stadium","to":"Toad's Factory"},{"from":"Peach Stadium","to":"Rainbow Road"},
  {"from":"Rainbow Road","to":"Peach Stadium"},
  {"from":"Salty Salty Speedway","to":"Cheep Cheep Falls"},{"from":"Salty Salty Speedway","to":"Dino Dino Jungle"},{"from":"Salty Salty Speedway","to":"DK Pass"},{"from":"Salty Salty Speedway","to":"Faraway Oasis"},{"from":"Salty Salty Speedway","to":"Great ? Block Ruins"},{"from":"Salty Salty Speedway","to":"Peach Beach"},{"from":"Salty Salty Speedway","to":"Wario Shipyard"},{"from":"Salty Salty Speedway","to":"Sky-High Sundae"},
  {"from":"Shy Guy Bazaar","to":"Airship Fortress"},{"from":"Shy Guy Bazaar","to":"Choco Mountain"},{"from":"Shy Guy Bazaar","to":"Desert Hills"},{"from":"Shy Guy Bazaar","to":"Mario Bros. Circuit"},{"from":"Shy Guy Bazaar","to":"Wario Stadium"},
  {"from":"Sky-High Sundae","to":"Dandelion Depths"},{"from":"Sky-High Sundae","to":"DK Pass"},{"from":"Sky-High Sundae","to":"Starview Peak"},{"from":"Sky-High Sundae","to":"Wario Shipyard"},{"from":"Sky-High Sundae","to":"Cheep Cheep Falls"},{"from":"Sky-High Sundae","to":"Salty Salty Speedway"},
  {"from":"Starview Peak","to":"Boo Cinema"},{"from":"Starview Peak","to":"Cheep Cheep Falls"},{"from":"Starview Peak","to":"Dandelion Depths"},{"from":"Starview Peak","to":"DK Pass"},{"from":"Starview Peak","to":"Mario Circuit"},{"from":"Starview Peak","to":"Sky-High Sundae"},{"from":"Starview Peak","to":"Wario Shipyard"},
  {"from":"Toad's Factory","to":"Acorn Heights"},{"from":"Toad's Factory","to":"Airship Fortress"},{"from":"Toad's Factory","to":"Bowser's Castle"},{"from":"Toad's Factory","to":"Choco Mountain"},{"from":"Toad's Factory","to":"Dandelion Depths"},{"from":"Toad's Factory","to":"Dry Bones Burnout"},{"from":"Toad's Factory","to":"Mario Bros. Circuit"},{"from":"Toad's Factory","to":"Mario Circuit"},{"from":"Toad's Factory","to":"Moo Moo Meadows"},{"from":"Toad's Factory","to":"Peach Stadium"},{"from":"Toad's Factory","to":"Wario Stadium"},
  {"from":"Wario Shipyard","to":"Cheep Cheep Falls"},{"from":"Wario Shipyard","to":"DK Pass"},{"from":"Wario Shipyard","to":"Peach Beach"},{"from":"Wario Shipyard","to":"Salty Salty Speedway"},{"from":"Wario Shipyard","to":"Sky-High Sundae"},{"from":"Wario Shipyard","to":"Starview Peak"},
  {"from":"Wario Stadium","to":"Airship Fortress"},{"from":"Wario Stadium","to":"Bowser's Castle"},{"from":"Wario Stadium","to":"Choco Mountain"},{"from":"Wario Stadium","to":"Crown City"},{"from":"Wario Stadium","to":"Dry Bones Burnout"},{"from":"Wario Stadium","to":"Mario Bros. Circuit"},{"from":"Wario Stadium","to":"Shy Guy Bazaar"},{"from":"Wario Stadium","to":"Toad's Factory"},
  {"from":"Whistlestop Summit","to":"Choco Mountain"},{"from":"Whistlestop Summit","to":"Crown City"},{"from":"Whistlestop Summit","to":"Desert Hills"},{"from":"Whistlestop Summit","to":"DK Spaceport"},{"from":"Whistlestop Summit","to":"Mario Bros. Circuit"}
];

function buildRouteIndex(routes){
  const startToEnds = new Map();
  const endToStarts = new Map();
  for (const r of routes){
    if (!startToEnds.has(r.from)) startToEnds.set(r.from, new Set());
    startToEnds.get(r.from).add(r.to);
    if (!endToStarts.has(r.to)) endToStarts.set(r.to, new Set());
    endToStarts.get(r.to).add(r.from);
  }
  return { startToEnds, endToStarts };
}

const ROUTE_INDEX = buildRouteIndex(INTERMISSION_ROUTES);

function fillTrackSelect(selectEl, placeholder){
  selectEl.innerHTML = "";
  const opt0 = document.createElement("option");
  opt0.value = "";
  opt0.textContent = placeholder || "—";
  selectEl.appendChild(opt0);

  // Deterministic ordering:
  // - If this is an Intermission-start select, put EXACTLY ONE suggested track (latest match target)
  //   right under the placeholder and mark it visually (★), but keep value as the raw track name.
  // - Under that: all other tracks in strict alphabetical order, excluding the suggested track.
  // - Never keep/accumulate old suggestions because we rebuild the options from scratch every time.
  const suggested = (getSuggestedNextStart?.() || '');
  const isStartSelect = (selectEl?.id === 'intermission' || selectEl?.id === 'editIntermission');

  const sortedAll = [...TRACKS].sort((a,b)=>String(a).localeCompare(String(b)));

  if (isStartSelect && suggested && sortedAll.includes(suggested)){
    const o = document.createElement('option');
    o.value = suggested;
    o.textContent = `★ ${suggested}`;
    o.dataset.suggested = '1';
    selectEl.appendChild(o);
  }

  for (const t of sortedAll){
    if (isStartSelect && suggested && t === suggested) continue;
    const o = document.createElement('option');
    o.value = t;
    o.textContent = t;
    selectEl.appendChild(o);
  }
}

// ========= Intermission dropdown filtering (bidirectional) =========
// Rules:
// - If user picks Start (A), End dropdown only shows valid destinations for A.
// - If user picks End (B), Start dropdown only shows valid starts that can reach B.
// - Clearing a field resets the opposite dropdown back to the full TRACKS list.

const _startsToEnds = new Map();   // from -> Set(to)
const _endsToStarts = new Map();   // to   -> Set(from)

(function buildIntermissionMaps(){
  for (const r of INTERMISSION_ROUTES){
    if (!_startsToEnds.has(r.from)) _startsToEnds.set(r.from, new Set());
    _startsToEnds.get(r.from).add(r.to);

    if (!_endsToStarts.has(r.to)) _endsToStarts.set(r.to, new Set());
    _endsToStarts.get(r.to).add(r.from);
  }
})();

function fillTrackSelectFromList(selectEl, placeholder, list){
  // Keeps placeholder, then fills only the provided list.
  selectEl.innerHTML = "";
  const opt0 = document.createElement("option");
  opt0.value = "";
  opt0.textContent = placeholder || "—";
  selectEl.appendChild(opt0);

  const arr = Array.isArray(list) ? list : [];
  const suggested = (getSuggestedNextStart?.() || '');
  const isStartSelect = (selectEl?.id === 'intermission' || selectEl?.id === 'editIntermission');

  // Always keep the non-suggested part strictly alphabetical.
  const sorted = [...arr].sort((a,b)=>String(a).localeCompare(String(b)));

  // EXACTLY ONE suggested option at the top (only if currently allowed by the filter).
  if (isStartSelect && suggested && sorted.includes(suggested)){
    const o = document.createElement('option');
    o.value = suggested;
    o.textContent = `★ ${suggested}`;
    o.dataset.suggested = '1';
    selectEl.appendChild(o);
  }

  for (const t of sorted){
    if (isStartSelect && suggested && t === suggested) continue;
    const o = document.createElement('option');
    o.value = t;
    o.textContent = t;
    selectEl.appendChild(o);
  }
}

function updateIntermissionPair(startEl, endEl, startPlaceholder, endPlaceholder){
  // Bidirectional filtering with loop-prevention.
  let isSyncing = false;

  function syncFromStart(){
    if (isSyncing) return;
    isSyncing = true;
    const startVal = startEl.value;
    const prevEnd  = endEl.value;

    // If Start is cleared (default), BOTH selects should return to full options.
    // Also clear the counterpart value to avoid "remembering" a filtered state.
    if (!startVal){
      fillTrackSelect(startEl, startPlaceholder);
      fillTrackSelect(endEl, endPlaceholder);
      startEl.value = "";
      endEl.value = "";
      isSyncing = false;
      return;
    }

    const allowed = Array.from(_startsToEnds.get(startVal) || []).sort();
    fillTrackSelectFromList(endEl, endPlaceholder, allowed);

    // Preserve previous selection if still valid; otherwise clear.
    endEl.value = allowed.includes(prevEnd) ? prevEnd : "";
    isSyncing = false;
  }

  function syncFromEnd(){
    if (isSyncing) return;
    isSyncing = true;
    const endVal   = endEl.value;
    const prevStart = startEl.value;

    // If End is cleared (default), BOTH selects should return to full options.
    // Also clear the counterpart value to avoid "remembering" a filtered state.
    if (!endVal){
      fillTrackSelect(startEl, startPlaceholder);
      fillTrackSelect(endEl, endPlaceholder);
      startEl.value = "";
      endEl.value = "";
      isSyncing = false;
      return;
    }

    const allowed = Array.from(_endsToStarts.get(endVal) || []).sort();
    fillTrackSelectFromList(startEl, startPlaceholder, allowed);
    startEl.value = allowed.includes(prevStart) ? prevStart : "";
    isSyncing = false;
  }

  startEl.addEventListener("change", syncFromStart);
  endEl.addEventListener("change", syncFromEnd);

  // Initial state: full lists
  fillTrackSelect(startEl, startPlaceholder);
  fillTrackSelect(endEl, endPlaceholder);
}

function initSelects(){
  // Intermission (create form)
  updateIntermissionPair(
    $("intermission"),
    $("track"),
    " ",
    " "
  );

  // Intermission (edit dialog)
  updateIntermissionPair(
    $("editIntermission"),
    $("editTrack"),
    " ",
    " "
  );
}

// Reset helper for create-form Intermission selects (values + full options + suggestion)
// Uses the existing bidirectional filter logic via change-events.
function resetIntermissionSelects(){
  const a = $("intermission");
  const b = $("track");
  if (!a || !b) return;
  a.value = "";
  b.value = "";
  try {
    a.dispatchEvent(new Event("change", { bubbles: true }));
    b.dispatchEvent(new Event("change", { bubbles: true }));
  } catch(e) {}
}
  // ========= Supabase (FIX: localStorage + sessionStorage unterstützen) =========
  const SUPABASE_URL  = "https://imxlssgtzzdfgdscubdx.supabase.co";
  const SUPABASE_ANON = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImlteGxzc2d0enpkZmdkc2N1YmR4Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjgxMjI2NDYsImV4cCI6MjA4MzY5ODY0Nn0.b5nRQ1ryAC4_TMrmC5qIXx7Gm2hDzrR51Z6RVks2Wg4";

  function makeClient(storage) {
    return window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON, {
      auth: {
        storage,
        persistSession: true,
        autoRefreshToken: true,
        detectSessionInUrl: true,
      }
    });
  }

  const clientLocal = makeClient(localStorage);
  const clientSess  = makeClient(sessionStorage);

  // wird nach requireAuth() gesetzt
  let supabaseClient = null;

  let SESSION = null;
  let PROFILE = null;

    // ===== Pagination =====
    const PAGE_SIZE = 7;
    let currentPage = 1;
    let totalMatches = null;

  // ========= Auth Guard (FIX: check localStorage ODER sessionStorage) =========
  async function requireAuth() {
    // 1) localStorage
    let { data: { session }, error } = await clientLocal.auth.getSession();
    if (error) setDebug("getSession(local) error: " + JSON.stringify(error, null, 2));
    if (session) {
      supabaseClient = clientLocal;
      SESSION = session;
      $("userInfo").textContent = "Profile: –";
      return session;
    }

    // 2) sessionStorage
    ({ data: { session }, error } = await clientSess.auth.getSession());
    if (error) setDebug("getSession(session) error: " + JSON.stringify(error, null, 2));
    if (session) {
      supabaseClient = clientSess;
      SESSION = session;
      $("userInfo").textContent = "Profile: –";
      return session;
    }

    // 3) keine session -> zurück zum Login
    window.location.href = "login.html";
    return null;
  }

  // ========= Profile =========
  async function loadProfile() {
    PROFILE = null;
    $("currentVrPill").textContent = "–";

    const { data, error } = await supabaseClient
      .from("profiles")
      .select("id, nickname, current_vr")
      .eq("id", SESSION.user.id)
      .maybeSingle();

    if (error) {
      setStatus("Failed to load profile: " + error.message, false);
      setDebug(JSON.stringify(error, null, 2));
      return;
    }

    if (!data) {
      PROFILE = null;
      return;
    }

    PROFILE = data;
    
  // Anzeige im Header: Nickname
  try { $("userInfo").textContent = "Profile: " + (PROFILE?.nickname || "–"); } catch(e) {}
$("currentVrPill").textContent = String(PROFILE.current_vr ?? "–");
  }

  async function createProfile() {
    const btn = $("btnCreateProfile");
    btn.disabled = true;

    try {
      const nickname = $("setupNickname").value.trim();
      const vrRaw = $("setupVr").value;
      const current_vr = (vrRaw === "" ? 8500 : parseInt(vrRaw, 10));

      if (!nickname) { setStatus("Please enter a nickname.", false); return; }
      if (!Number.isFinite(current_vr)) { setStatus("Invalid VR value.", false); return; }

      setStatus("Creating profile…", true);

      const { error } = await supabaseClient.from("profiles").insert({
        id: SESSION.user.id,
        nickname,
        current_vr
      });

      if (error) {
        setStatus("Create profile fehlgeschlagen: " + error.message, false);
        setDebug(JSON.stringify(error, null, 2));
        return;
      }

      setStatus("✅ Profile created.", true);
      await refreshAll();
    } finally {
      btn.disabled = false;
    }
  }

  
/* saveSettings removed (moved to settings.html) */


 // ========= Matches (Pagination) =========

async function getMatchesCount() {
  const { count, error } = await supabaseClient
    .from("matches")
    .select("id", { count: "exact", head: true })
    .eq("user_id", SESSION.user.id);

  if (error) {
    setDebug("Count error: " + JSON.stringify(error, null, 2));
    return null;
  }
  return count ?? null;
}

async function loadMatches() {
  $rows.innerHTML = `<tr><td colspan="10" class="muted">Loading…</td></tr>`;

  // Count nur holen wenn noch nicht da
  if (totalMatches == null) {
    totalMatches = await getMatchesCount();
  }

  const from = (currentPage - 1) * PAGE_SIZE;
  const to   = from + PAGE_SIZE - 1;

  const { data, error } = await supabaseClient
    .from("matches")
    .select("id, created_at, intermission, track, vr_change, vr_after, opponents, placement")
    .eq("user_id", SESSION.user.id)
    // Deterministic ordering: created_at can collide (same second), so also order by id.
    .order("created_at", { ascending: false })
    .order("id", { ascending: false })
    .range(from, to);

  if (error) {
    setStatus("Failed to load matches: " + error.message, false);
    setDebug(JSON.stringify(error, null, 2));
    $rows.innerHTML = `<tr><td colspan="10" class="muted">Error loading.</td></tr>`;
    return;
  }

  
  // INIT/UPDATE_SUGGESTION_FROM_LATEST_MATCH:
  // Always keep Suggestion in sync with the newest (top) match.
  // Only do this on page 1 (which contains the newest match). Otherwise pagination
  // would overwrite the suggestion with older tracks.
  try {
    if (currentPage === 1) {
      const latest = (data && data.length && data[0] && data[0].track) ? String(data[0].track) : "";
      if (latest) {
        setLastSuggestedTrack(latest);
      } else {
        // No matches left => remove suggestion
        try { localStorage.removeItem('mkwt_last_next_start'); } catch(e) {}
      }

      // Update the *visible* Suggestion option immediately in the create-form start select.
      // This avoids stale Suggestion labels after delete/restore without resetting filters.
      try { refreshSuggestionOptionInStartSelect($("intermission")); } catch(e) {}
    }
  } catch(e) {}

  if (!data || data.length === 0) {
    $rows.innerHTML = `<tr><td colspan="10" class="muted">No matches yet.</td></tr>`;
    $("pageInfo").textContent = "Page 1";
    $("btnPrev").disabled = true;
    $("btnNext").disabled = true;
    return;
  }

  const maxPage = (totalMatches != null) ? Math.max(1, Math.ceil(totalMatches / PAGE_SIZE)) : null;
  $("pageInfo").textContent = maxPage ? `Page ${currentPage} / ${maxPage}` : `Page ${currentPage}`;
  $("btnPrev").disabled = (currentPage <= 1);
  $("btnNext").disabled = (maxPage != null) ? (currentPage >= maxPage) : (data.length < PAGE_SIZE);

  $rows.innerHTML = data.map((r, idx) => {
      const matchNo = totalMatches - (from + idx); // newest gets highest number
      const created = r.created_at ? new Date(r.created_at).toLocaleString("de-DE") : "";
      const intermission = (r.intermission ?? "") ? String(r.intermission) : "";
      const track = (r.track ?? "") ? String(r.track) : "";
      const isIntermission = !!intermission;
      const intermissionCellHtml = isIntermission
        ? `<div class="intermission-stack"><div class="label">Start</div><div class="value">${escapeHtml(intermission)}</div><div class="label">End</div><div class="value">${escapeHtml(track)}</div></div>`
        : `<span class="intermission-placeholder">—</span>`;
      const trackCellHtml = isIntermission
        ? `<span class="track-placeholder">—</span>`
        : escapeHtml(track || '—');
      const delta = Number(r.vr_change || 0);
      const vrAfter = (r.vr_after ?? null);
      const vrNow = (vrAfter == null ? "" : Number(vrAfter));
      const opp = Number(r.opponents || 0);
      const place = Number(r.placement || 0);
      const perf = (opp ? (delta / opp) : 0);
      const perfStr = opp ? perf.toFixed(2) : "";
      const canDelete = (currentPage === 1 && idx === 0); // only newest match can be deleted
      return `
        <tr>
          <td>${matchNo}</td>
          <td>${created}</td>
          <td>${intermissionCellHtml}</td>
          <td>${trackCellHtml}</td>
          <td class="${delta>=0?'ok':'bad'}">${delta}</td>
          <td>${vrNow}</td>
          <td>${opp||""}</td>
          <td>${place||""}</td>
          <td>
            <button class="iconBtn" title="Bearbeiten" data-action="edit" data-id="${r.id}">✏️</button>
            ${canDelete ? `<button class="iconBtn danger" title="Löschen" data-action="del" data-id="${r.id}">🗑️</button>` : ""}
          </td>
        </tr>`;
    }).join("");

  // Klick-Handler für Edit & Delete
  $rows.querySelectorAll("button[data-action]").forEach(btn => {
    btn.addEventListener("click", async () => {
      const id = btn.getAttribute("data-id");
      const action = btn.getAttribute("data-action");
      if (action === "edit") await openEditDialog(id);
      if (action === "del") await deleteMatch(id);
    });
  });
}

  async function saveMatch() {
    const btn = $("btnSaveMatch");
    btn.disabled = true;

    try {
      const mode = document.querySelector(".modeBtn.isActive")?.dataset.mode || "intermission";
      const intermissionSel = $("intermission");
      const intermission = (mode === "intermission") ? (intermissionSel?.value || null) : null;
      const track = $("track").value;
      const vr_change_raw = $("vrChange").value;
      const vr_after_raw = $("vrAfterInput")?.value;
      const vr_change_in = (vr_change_raw === "" ? NaN : parseInt(vr_change_raw, 10));
      const vr_after_in = (vr_after_raw === "" || vr_after_raw == null ? NaN : parseInt(vr_after_raw, 10));
const opponentsRaw = $("opponents").value;
      const placementRaw = $("placement").value;

        if (!track) { setStatus("Please select a track.", false); return; }
    if (mode === "intermission" && !intermission) { setStatus("Please select an intermission start.", false); return; }
      if (!Number.isFinite(vr_change_in) && !Number.isFinite(vr_after_in)) { setStatus("Please enter VR Δ or VR after match.", false); return; }

      let opponents = null;
      if (opponentsRaw !== "") {
        opponents = parseInt(opponentsRaw, 10);
        if (!Number.isFinite(opponents) || opponents < 1 || opponents > 23) {
          setStatus("Opponents must be 1–23.", false);
          return;
        }
      }

      let placement = null;
      if (placementRaw !== "") {
        placement = parseInt(placementRaw, 10);
        if (!Number.isFinite(placement) || placement < 1 || placement > 24) {
          setStatus("Placement must be 1–24.", false);
          return;
        }
      }

      setStatus("Saving match…", true);

      const baseVr = (PROFILE?.current_vr ?? 8500);
      let vr_after;
      let vr_change;
      if (Number.isFinite(vr_after_in)) {
        vr_after = vr_after_in;
        vr_change = vr_after - baseVr;
        // Sync UI, falls beides gefüllt war
        try { if ($("vrChange")) $("vrChange").value = String(vr_change); } catch(e) {}
      } else {
        vr_change = vr_change_in;
        vr_after = baseVr + vr_change;
        try { if ($("vrAfterInput")) $("vrAfterInput").value = String(vr_after); } catch(e) {}
      }
const { error: insErr } = await supabaseClient.from("matches").insert({
        user_id: SESSION.user.id,
        intermission,
        track,
        vr_change,
        vr_after, // Snapshot: VR nach diesem Match
        opponents,
        placement
      });

      if (insErr) {
        setStatus("Failed to save match: " + insErr.message, false);
        setDebug(JSON.stringify(insErr, null, 2));
        return;
      }


      // === Instant Placeholder Suggestion + Instant Clear (same behavior as Clear) ===
      // Do this immediately after the match insert succeeds, before any other network calls.
      try { setLastSuggestedTrack(track); } catch(e) {}
      try {
        const a = $('intermission');
        const b = $('track');
        if (a && b) {
          fillTrackSelect(a, ' ');
          fillTrackSelect(b, ' ');
          a.value = '';
          b.value = '';
          a.dispatchEvent(new Event('change', { bubbles: true }));
          b.dispatchEvent(new Event('change', { bubbles: true }));
          // Ensure placeholder text reflects the new suggestion instantly
          refreshSuggestionOptionInStartSelect(a);
        }
      } catch(e) {}
      try { $('vrChange').value = ''; } catch(e) {}
      try { $('vrAfterInput').value = ''; } catch(e) {}
      try { $('opponents').value = ''; } catch(e) {}
      try { $('placement').value = ''; } catch(e) {}
      const newVr = vr_after;

      const { error: upErr } = await supabaseClient
        .from("profiles")
        .update({ current_vr: newVr, updated_at: new Date().toISOString() })
        .eq("id", SESSION.user.id);

      if (upErr) {
        setStatus("⚠️ Match saved, but VR update failed: " + upErr.message, false);
        setDebug(JSON.stringify(upErr, null, 2));
      } else {
        setStatus("✅ Match saved. VR updated.", true);
      }



      await refreshAll();
    } finally {
      btn.disabled = false;
    }
  }

  // ========= Logout (FIX: beide storages leeren) =========
  async function logout() {
    setStatus("Logging out…", true);

    // beide Varianten abmelden
    await clientLocal.auth.signOut();
    await clientSess.auth.signOut();

    window.location.href = "login.html";
  }

  // ========= Refresh / Init =========
  async function refreshAll() {
  setStatus("", true);

  // Pagination-Cache reset (WICHTIG!)
  totalMatches = null;
  currentPage = 1;

  await loadProfile();

    if (!PROFILE) {
      show($("setupCard"), true);
      show($("matchCard"), false);
      show($("listCard"), false);
      $("currentVrPill").textContent = "–";
      return;
    }

    show($("setupCard"), false);
    show($("matchCard"), true);
    show($("listCard"), true);

    $("currentVrPill").textContent = String(PROFILE.current_vr ?? "–");
    // Re-sync inputs with new base VR
    try { syncFromDelta(); syncFromAfter(); } catch(e) {}
    await loadMatches();
  }
// ========= Edit / Delete =========
const editDlg = $("editDlg");
let EDIT_ROW = null;

async function fetchMatchById(id) {
  const { data, error } = await supabaseClient
    .from("matches")
    .select("id, created_at, intermission, track, vr_change, vr_after, opponents, placement")
    .eq("id", id)
    .eq("user_id", SESSION.user.id)
    .maybeSingle();

  if (error) throw error;
  return data;
}

async function openEditDialog(id) {
  try {
    setStatus("", true);
    EDIT_ROW = await fetchMatchById(id);
    if (!EDIT_ROW) {
      setStatus("Match nicht gefunden (oder keine Rechte).", false);
      return;
    }

    $("editMeta").textContent =
      "ID: " + EDIT_ROW.id + " • " +
      (EDIT_ROW.created_at ? new Date(EDIT_ROW.created_at).toLocaleString() : "");

    $("editIntermission").value = "";
    $("editTrack").value = "";
    // Reset edit selects to full options (no leftover filtered combos)
    // Uses the existing bidirectional filter logic via change-events.
    try {
      $("editIntermission").dispatchEvent(new Event("change", { bubbles: true }));
      $("editTrack").dispatchEvent(new Event("change", { bubbles: true }));
    } catch(e) {}

    // Mode UI (Intermission vs 3-Lap)
    try { setEditMode((EDIT_ROW.intermission ?? "") ? "intermission" : "3lap"); } catch(e) {}

    $("editVrChange").value = (EDIT_ROW.vr_change ?? "");
    // keep edit negative-toggle button state in sync
    try {
      const b = document.getElementById("editVrSignToggle");
      const i = document.getElementById("editVrChange");
      if (b && i) setNegButtonState(b, i);
    } catch(e) {}
    if ($("editVrAfter")) $("editVrAfter").value = (EDIT_ROW.vr_after ?? "");
    // bind live sync (same behavior as add match)
    $("editVrChange")?.removeEventListener("input", editSyncFromDelta);
    $("editVrAfter")?.removeEventListener("input", editSyncFromAfter);
    $("editVrChange")?.addEventListener("input", editSyncFromDelta);
    $("editVrAfter")?.addEventListener("input", editSyncFromAfter);

    $("editOpponents").value = (EDIT_ROW.opponents ?? "");
    $("editPlacement").value = (EDIT_ROW.placement ?? "");

    editDlg.showModal();
  } catch (e) {
    setStatus("Failed to open editor: " + (e?.message || e), false);
    setDebug(e?.stack || "");
  }
}

function closeDlg(){
  if (editDlg.open) editDlg.close();
  EDIT_ROW = null;
}

async function saveEditDialog(){
  if (!EDIT_ROW) return;

  const btn = $("btnSaveDlg");
  btn.disabled = true;

  try {
    const mode = document.getElementById("editDlg")?.dataset.mode || ((EDIT_ROW?.intermission ?? "") ? "intermission" : "3lap");
    const intermission = (mode === "intermission") ? ($("editIntermission").value || null) : null;
    const track = $("editTrack").value;
    const vrChangeRaw = $("editVrChange").value;
    const vrAfterRaw  = $("editVrAfter") ? $("editVrAfter").value : "";
    const vr_change_in = (vrChangeRaw === "" ? NaN : parseInt(vrChangeRaw, 10));
    const vr_after_in  = (vrAfterRaw === ""  ? NaN : parseInt(vrAfterRaw, 10));
    const opponentsRaw = $("editOpponents").value;
    const placementRaw = $("editPlacement").value;

    if (!track) { setStatus("Please select a track.", false); return; }
    if (mode === "intermission" && !intermission) { setStatus("Please select an intermission start.", false); return; }
    if (!Number.isFinite(vr_change_in) && !Number.isFinite(vr_after_in)) { setStatus("Please enter VR Δ or new total VR.", false); return; }

    let opponents = null;
    if (opponentsRaw !== "") {
      opponents = parseInt(opponentsRaw, 10);
      if (!Number.isFinite(opponents) || opponents < 1 || opponents > 23) {
        setStatus("Opponents must be 1–23.", false);
        return;
      }
    }

    let placement = null;
    if (placementRaw !== "") {
      placement = parseInt(placementRaw, 10);
      if (!Number.isFinite(placement) || placement < 1 || placement > 24) {
        setStatus("Placement must be 1–24.", false);
        return;
      }
    }

    const baseVr = getEditBaseVr();

    let vr_change;
    let vr_after;

    if (Number.isFinite(vr_after_in)) {
      vr_after = vr_after_in;
      vr_change = vr_after - baseVr;
      // keep UI consistent
      try { $("editVrChange").value = String(vr_change); } catch(e) {}
    } else {
      vr_change = vr_change_in;
      vr_after = baseVr + vr_change;
      try { if ($("editVrAfter")) $("editVrAfter").value = String(vr_after); } catch(e) {}
    }

    const oldVr = (EDIT_ROW.vr_change ?? 0);
    const deltaVr = vr_change - oldVr; // profile VR adjustment

    setStatus("Saving changes…", true);

    // 1) Match updaten + updated row zurückholen (wichtig: array!)
    const { data: updatedRows, error: upMatchErr } = await supabaseClient
    .from("matches")
    .update({ intermission, track, vr_change, vr_after, opponents, placement })
    .eq("id", EDIT_ROW.id)
    .eq("user_id", SESSION.user.id)
    .select("id, vr_change, vr_after, intermission, track, opponents, placement");

    if (upMatchErr) {
    setStatus("Match update failed: " + upMatchErr.message, false);
    setDebug(JSON.stringify(upMatchErr, null, 2));
    return;
    }

    if (!updatedRows || updatedRows.length === 0) {
    setStatus("Match was NOT changed (0 Zeilen getroffen). Prüfe user_id / RLS Policy.", false);
    setDebug(
        "Update hit 0 rows.\n" +
        "EDIT_ROW.id=" + EDIT_ROW.id + "\n" +
        "SESSION.user.id=" + SESSION.user.id + "\n" +
        "Tipp: Prüfe in Supabase, ob matches.user_id wirklich dein User ist."
    );
    return;
}

    if (deltaVr !== 0) {
      await loadProfile();
      const fixed = (PROFILE?.current_vr ?? 8500) + deltaVr;

      const { error: upProfErr } = await supabaseClient
        .from("profiles")
        .update({ current_vr: fixed, updated_at: new Date().toISOString() })
        .eq("id", SESSION.user.id);

      if (upProfErr) {
        setStatus("⚠️ Match geändert, aber Profil-VR Korrektur fehlgeschlagen: " + upProfErr.message, false);
        setDebug(JSON.stringify(upProfErr, null, 2));
        closeDlg();
        await refreshAll();
        return;
      }
    }

    setStatus("✅ Changes saved.", true);
    closeDlg();
    await refreshAll();

  } catch (e) {
    setStatus("Save fehlgeschlagen: " + (e?.message || e), false);
    setDebug(e?.stack || "");
  } finally {
    btn.disabled = false;
  }
}

async function deleteMatch(id){
  try {
    const row = await fetchMatchById(id);
    if (!row) { setStatus("Match nicht gefunden.", false); return; }

    const ok = confirm(
      `Delete match?\n\nTrack: ${row.track}\nVR Δ: ${row.vr_change}\nZeit: ${row.created_at ? new Date(row.created_at).toLocaleString() : ""}`
    );
    if (!ok) return;

    setStatus("Deleting match…", true);

    const { error: delErr } = await supabaseClient
      .from("matches")
      .delete()
      .eq("id", id)
      .eq("user_id", SESSION.user.id);

    if (delErr) {
      setStatus("Delete failed: " + delErr.message, false);
      setDebug(JSON.stringify(delErr, null, 2));
      return;
    }

    // Profil-VR korrigieren: Einfluss dieses Matches entfernen
    const oldVr = (row.vr_change ?? 0);
    await loadProfile();
    const fixed = (PROFILE?.current_vr ?? 8500) - oldVr;

    const { error: upProfErr } = await supabaseClient
      .from("profiles")
      .update({ current_vr: fixed, updated_at: new Date().toISOString() })
      .eq("id", SESSION.user.id);

    if (upProfErr) {
      setStatus("⚠️ Match gelöscht, aber Profil-VR Korrektur fehlgeschlagen: " + upProfErr.message, false);
      setDebug(JSON.stringify(upProfErr, null, 2));
    } else {
      setStatus("✅ Match deleted. VR adjusted.", true);
    }

    // Make Suggestion update feel instant:
    // - Remove the deleted row from the table immediately (delete is only allowed for the newest row).
    // - Set suggestion to the new top-most match target track (end track for intermission, track for 3-lap).
    // This avoids waiting for refreshAll/network before the Suggestion option appears.
    try {
      const btn = document.querySelector(`button[data-action="del"][data-id="${id}"]`);
      const tr = btn ? btn.closest('tr') : null;
      if (tr && tr.parentElement) tr.parentElement.removeChild(tr);

      const nextTop = getTopMatchTargetTrackFromTable();
      if (nextTop) {
        setLastSuggestedTrack(nextTop);
      } else {
        try { localStorage.removeItem('mkwt_last_next_start'); } catch(e) {}
      }
      refreshSuggestionOptionInStartSelect($("intermission"));
    } catch(e) {}

    await refreshAll();
  } catch (e) {
    setStatus("Delete failed: " + (e?.message || e), false);
    setDebug(e?.stack || "");
  }
}
  // Buttons
  $("btnLogout").addEventListener("click", logout);
  $("btnCreateProfile").addEventListener("click", createProfile);
  $("btnSaveMatch").addEventListener("click", saveMatch);

  // Live-Sync der Eingabefelder
  $("vrChange")?.addEventListener("input", syncFromDelta);
  $("vrAfterInput")?.addEventListener("input", syncFromAfter);

  $("btnClear").addEventListener("click", () => {
    const a = $("intermission");
    const b = $("track");
    a.value = "";
    b.value = "";
    // IMPORTANT: trigger the intermission filter logic to repopulate BOTH dropdowns
    // back to the full 30-track list when placeholders are selected.
    a.dispatchEvent(new Event("change", { bubbles: true }));
    b.dispatchEvent(new Event("change", { bubbles: true }));

    $("vrChange").value = "";
    $("vrAfterInput").value = "";
    $("opponents").value = "";
    $("placement").value = "";
    setStatus("", true);
    setDebug("");
  });
  $("btnExport")?.addEventListener("click", exportBackupJSON);

    $("fileImport")?.addEventListener("change", async (e) => {
    const file = e.target.files?.[0];
    // reset, damit gleiche Datei nochmal gewählt werden kann
    e.target.value = "";
    await importBackupJSON(file);
    });
    $("btnPrev").addEventListener("click", async () => {
  if (currentPage <= 1) return;
  currentPage--;
  await loadMatches();
    
  });

    $("btnNext").addEventListener("click", async () => {
  // wenn wir totalMatches kennen, nicht über maxPage hinaus
  if (totalMatches != null) {
    const maxPage = Math.max(1, Math.ceil(totalMatches / PAGE_SIZE));
    if (currentPage >= maxPage) return;
  }

  currentPage++;
  await loadMatches();
    });
    // ===== Dialog Buttons (PART 7) =====
    $("btnCloseDlg")?.addEventListener("click", closeDlg);
    $("btnCancelDlg")?.addEventListener("click", closeDlg);
    $("btnSaveDlg")?.addEventListener("click", saveEditDialog);

    // Optional: ESC / Klick auf Backdrop -> schließt Dialog
    $("editDlg")?.addEventListener("cancel", (e) => { e.preventDefault(); closeDlg(); });

    function fixDatalistReopen(inputId) {
    const el = document.getElementById(inputId);
    if (!el) return;

    el.addEventListener("focus", () => {
        // Kurz leeren → Browser vergisst den Filter
        const v = el.value;
        el.value = "";
        requestAnimationFrame(() => el.value = v);
    });
    }

    // Für beide Felder aktivieren
    fixDatalistReopen("editPlacement");
    fixDatalistReopen("editOpponents");

  // Start
  (async () => {
    setDebug("App starting…");

    // Selects (Intermission/Track + Edit-Dialog) befüllen
    initSelects();

    const s = await requireAuth();
    if (!s) return;

    await refreshAll();
    setDebug("Ready.");
})();
</script>








<script>
(function(){
  function wireSelectAll(input){
    if (!input) return;
    input.addEventListener("focus", () => {
      input.dataset.prev = input.value || "";
      // iOS: select needs a tick after focus
      setTimeout(() => { try { input.select(); } catch(e){} }, 0);
    });
    input.addEventListener("blur", () => {
      if ((input.value || "").trim() === "") {
        input.value = input.dataset.prev || "";
      }
    });
  }

  function setNegButtonState(btn, input){
    if (!btn || !input) return;
    const isNeg = (input.value || "").startsWith("-");
    btn.classList.toggle("is-negative", isNeg);
  }

  document.addEventListener("DOMContentLoaded", () => {
    // --- Match mode toggle (Intermission vs 3-Lap) ---
    const modeBtns = Array.from(document.querySelectorAll(".modeBtn"));
    const fieldIntermission = document.getElementById("fieldIntermissionStart");
    const labelIntermission = document.getElementById("labelIntermissionStart");
    const labelTrack = document.getElementById("labelTrack");
    const trackPlaceholder = document.getElementById("trackPlaceholder");
    const intermissionSel = document.getElementById("intermission");

    function setMode(mode){
      modeBtns.forEach(b => {
        const active = b.dataset.mode === mode;
        b.classList.toggle("isActive", active);
        b.setAttribute("aria-selected", active ? "true" : "false");
      });

      const isIntermission = (mode === "intermission");
      if (isIntermission) { try { resetIntermissionSelects(); } catch(e) {} }
      if (fieldIntermission) fieldIntermission.style.display = isIntermission ? "" : "none";
      if (!isIntermission && intermissionSel) intermissionSel.value = "";
      if (labelIntermission) labelIntermission.textContent = "Intermission start";
      if (labelTrack) labelTrack.textContent = isIntermission ? "Intermission end" : "Track";
      if (trackPlaceholder) trackPlaceholder.textContent = isIntermission ? "Intermission end" : "Track";
    }

    modeBtns.forEach(b => b.addEventListener("click", () => setMode(b.dataset.mode || "intermission")));
    // Default: Intermission (current behavior)
    setMode("intermission");

    const vr = document.getElementById("vrChange");
    const vrAfter = document.getElementById("vrAfterInput");
    const negBtn = document.getElementById("vrSignToggle");

    wireSelectAll(vr);
    wireSelectAll(vrAfter);

    if (negBtn && vr) {
      setNegButtonState(negBtn, vr);
      negBtn.addEventListener("click", (e) => {
        e.preventDefault();
        if (!vr.value) {
          vr.focus();
          return;
        }
        vr.value = vr.value.startsWith("-") ? vr.value.slice(1) : ("-" + vr.value);
        setNegButtonState(negBtn, vr);
        vr.dispatchEvent(new Event("input", { bubbles: true }));
        vr.focus();
        setTimeout(() => { try { vr.select(); } catch(e){} }, 0);
      });

      // If user manually clears/changes value, keep button state in sync
      vr.addEventListener("input", () => setNegButtonState(negBtn, vr));
    }

    // Edit dialog: same negative toggle for VR Δ
    const editVr = document.getElementById("editVrChange");
    const editNegBtn = document.getElementById("editVrSignToggle");
    if (editNegBtn && editVr) {
      setNegButtonState(editNegBtn, editVr);
      editNegBtn.addEventListener("click", (e) => {
        e.preventDefault();
        if (!editVr.value) {
          editVr.focus();
          return;
        }
        editVr.value = editVr.value.startsWith("-") ? editVr.value.slice(1) : ("-" + editVr.value);
        setNegButtonState(editNegBtn, editVr);
        editVr.dispatchEvent(new Event("input", { bubbles: true }));
        editVr.focus();
        setTimeout(() => { try { editVr.select(); } catch(e){} }, 0);
      });
      editVr.addEventListener("input", () => setNegButtonState(editNegBtn, editVr));
    }
  });
})();

</script>


<script>
function setEditMode(mode){
  const bI = document.getElementById('editModeIntermission');
  const b3 = document.getElementById('editMode3lap');
  const fieldStart = document.getElementById('editIntermissionField');
  const lblTrack = document.getElementById('editTrackLabel');
  const isInter = (mode === 'intermission');
  if (bI) bI.classList.toggle('isActive', isInter);
  if (b3) b3.classList.toggle('isActive', !isInter);
  if (fieldStart) fieldStart.style.display = isInter ? '' : 'none';
  if (lblTrack) lblTrack.textContent = isInter ? 'Intermission end' : 'Track';
  // store on dialog for save
  const dlg = document.getElementById('editDlg');
  if (dlg) dlg.dataset.mode = isInter ? 'intermission' : '3lap';
}

document.addEventListener('click', (e)=>{
  const btn = e.target.closest('#editModeIntermission, #editMode3lap');
  if (!btn) return;
  setEditMode(btn.dataset.mode);
});
</script>

</body>
</html>